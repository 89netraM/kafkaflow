"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[228],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>h});var s=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,s)}return r}function n(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,s,a=function(e,t){if(null==e)return{};var r,s,a={},o=Object.keys(e);for(s=0;s<o.length;s++)r=o[s],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)r=o[s],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var u=s.createContext({}),l=function(e){var t=s.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):n(n({},t),e)),r},m=function(e){var t=l(e.components);return s.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},c=s.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=l(r),h=a,d=c["".concat(u,".").concat(h)]||c[h]||p[h]||o;return r?s.createElement(d,n(n({ref:t},m),{},{components:r})):s.createElement(d,n({ref:t},m))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,n=new Array(o);n[0]=c;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i.mdxType="string"==typeof e?e:a,n[1]=i;for(var l=2;l<o;l++)n[l]=r[l];return s.createElement.apply(null,n)}return s.createElement.apply(null,r)}c.displayName="MDXCreateElement"},9553:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>n,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=r(7462),a=(r(7294),r(3905));const o={sidebar_position:4},n="Consumers",i={unversionedId:"guides/consumers",id:"guides/consumers",title:"Consumers",description:"Here is where KafkaFlow shines. Using KafkaFlow you have full control over how to consume the messages. Every consumer has its own Workers and Middlewares configuration. You can have multiple consumers consuming the same topic with different consumer groups or one consumer with multiple topics.",source:"@site/docs/guides/consumers.md",sourceDirName:"guides",slug:"/guides/consumers",permalink:"/docs/guides/consumers",draft:!1,editUrl:"https://github.com/farfetch/kafkaflow/tree/master/website/docs/guides/consumers.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Compressor",permalink:"/docs/guides/compressor"},next:{title:"Dashboard",permalink:"/docs/guides/dashboard"}},u={},l=[{value:"Message Flow",id:"message-flow",level:2},{value:"Kafka Consumer",id:"kafka-consumer",level:3},{value:"Consumer Worker Pool",id:"consumer-worker-pool",level:3},{value:"Distribution Strategy",id:"distribution-strategy",level:3},{value:"Workers",id:"workers",level:3},{value:"Middlewares",id:"middlewares",level:3},{value:"Offset Manager",id:"offset-manager",level:3},{value:"How it works",id:"how-it-works",level:2}],m={toc:l};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,s.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"consumers"},"Consumers"),(0,a.kt)("p",null,"Here is where KafkaFlow shines. Using KafkaFlow you have full control over how to consume the messages. Every consumer has its own ",(0,a.kt)("a",{parentName:"p",href:"#workers"},"Workers")," and ",(0,a.kt)("a",{parentName:"p",href:"#middlewares"},"Middlewares")," configuration. You can have multiple consumers consuming the same topic with different consumer groups or one consumer with multiple topics."),(0,a.kt)("h2",{id:"message-flow"},"Message Flow"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/233064/98690729-24bd8000-2365-11eb-8bd0-19e6aeeaebda.jpg",alt:"Message Flow"})),(0,a.kt)("p",null,"Every KafkaFlow consumer is composed by a group of components: ",(0,a.kt)("a",{parentName:"p",href:"#kafka-consumer"},"Kafka Consumer"),", ",(0,a.kt)("a",{parentName:"p",href:"#consumer-worker-pool"},"Consumer Worker Pool"),", ",(0,a.kt)("a",{parentName:"p",href:"#distribution-strategy"},"Distribution Strategy"),", ",(0,a.kt)("a",{parentName:"p",href:"#workers"},"Workers"),", ",(0,a.kt)("a",{parentName:"p",href:"#middlewares"},"Middlewares"),", and ",(0,a.kt)("a",{parentName:"p",href:"#offset-manager"},"Offset Manager"),"."),(0,a.kt)("h3",{id:"kafka-consumer"},"Kafka Consumer"),(0,a.kt)("p",null,"It\u2019s where the Confluent Client runs. It has a background task that fetches the messages from any topics/partitions assigned for that consumer and delivers them to the ",(0,a.kt)("a",{parentName:"p",href:"#consumer-worker-pool"},"Consumer Worker Pool"),". If the Confluent Consumer stops working for any reason (if a fatal exception occurs), the consumer will be recreated."),(0,a.kt)("h3",{id:"consumer-worker-pool"},"Consumer Worker Pool"),(0,a.kt)("p",null,"It orchestrates the Workers creation and destruction when the application starts, stops, and when partitions are assigned or revoked. It receives the message from ",(0,a.kt)("a",{parentName:"p",href:"#kafka-consumer"},"Kafka Consumer")," and uses the ",(0,a.kt)("a",{parentName:"p",href:"#distribution-strategy"},"Distribution Strategy")," to choose a ",(0,a.kt)("a",{parentName:"p",href:"#workers"},"Worker")," to enqueue the messages."),(0,a.kt)("h3",{id:"distribution-strategy"},"Distribution Strategy"),(0,a.kt)("p",null,"It\u2019s an algorithm to choose a ",(0,a.kt)("a",{parentName:"p",href:"#workers"},"Worker")," to process the message. The Framework has two: ",(0,a.kt)("strong",{parentName:"p"},"BytesSum")," and ",(0,a.kt)("strong",{parentName:"p"},"FreeWorker"),". The ",(0,a.kt)("strong",{parentName:"p"},"BytesSum")," maintains the message order with some performance and resource penalties, ",(0,a.kt)("strong",{parentName:"p"},"it is the default strategy"),". The ",(0,a.kt)("strong",{parentName:"p"},"FreeWorker")," is faster but the message order is lost. A custom strategy can be implemented using the ",(0,a.kt)("inlineCode",{parentName:"p"},"IDistibutionStrategy")," interface. You can configure the consumer's strategy during the configuration process with the method ",(0,a.kt)("inlineCode",{parentName:"p"},"WithWorkDistributionStrategy"),"."),(0,a.kt)("h3",{id:"workers"},"Workers"),(0,a.kt)("p",null,"Workers are responsible for processing messages when consuming. You define how many workers a consumer will have. The workers process the messages in parallel, and by default (using ByteSum distribution strategy), messages with the same partition key are processed by the same worker, so that the message order is respected for the same partition key. Every worker has a buffer to avoid idling when many messages arrive with the same partition key for any other worker. The buffer size should be dimensioned depending on how many messages arrive with the same partition key, on average. When the bus is requested to stop, every worker receives the stop command and it only releases the stop call when it ends the current message and stores it in the ",(0,a.kt)("a",{parentName:"p",href:"#offset-manager"},"Offset Manager"),"."),(0,a.kt)("h3",{id:"middlewares"},"Middlewares"),(0,a.kt)("p",null,"It\u2019s a customizable collection of middlewares. This collection is configurable per consumer. Middlewares can be created by implementing the ",(0,a.kt)("inlineCode",{parentName:"p"},"IMessageMiddleware")," interface. Each consumer has its own instances of middlewares, so, they aren't shared between consumers but they are shared between ",(0,a.kt)("a",{parentName:"p",href:"#workers"},"Workers"),". You can see more information about middlewares ",(0,a.kt)("a",{parentName:"p",href:"middlewares"},"here")),(0,a.kt)("h3",{id:"offset-manager"},"Offset Manager"),(0,a.kt)("p",null,"It is a component that receives all the offsets from the workers and orchestrates them before storing into Kafka; this avoids an offset override when we have many messages being processed at the same time. Even when you choose to use the manual offset store option, you will store the offset in the OffsetManager, and will then store the offsets in Kafka when possible. When the application stops, there is a big chance to have processed messages already stored in OffsetManager but not stored in Kafka. In this scenario, when the application starts again, these messages will be processed again. Your application must be prepared to deal with it."),(0,a.kt)("h2",{id:"how-it-works"},"How it works"),(0,a.kt)("p",null,"A sample consumer listening one topic with two ",(0,a.kt)("a",{parentName:"p",href:"#workers"},"Workers")," having a buffer size of 2 using the ",(0,a.kt)("strong",{parentName:"p"},"BytesSum")," distribution strategy."),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/233064/98690723-22f3bc80-2365-11eb-8453-04349abb103c.gif",alt:"consumer-animation"})))}p.isMDXComponent=!0}}]);